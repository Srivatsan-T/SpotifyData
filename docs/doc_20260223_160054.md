# `pages.cred` – User‑Login & Data Ingestion Page  
**File path:** `/app/cloned_repos/spotify_data/pages/cred.py`

The `cred` module is the entry point of the Spotify Analyzer web app.  
It presents a login form, authenticates the user with Spotify, pulls the user’s
liked and recently played tracks, and stores the data in a PostgreSQL database.
After a successful login the user is redirected to the *Tools* page.

---

## 1. Overview

| Feature | Description |
|---------|-------------|
| **Page registration** | `dash.register_page(__name__, path='/')` – the module is served at the root URL (`/`). |
| **Login UI** | A simple form with a text input for the Spotify username and a “Login” button. |
| **Data ingestion** | `fetch_data(username)` pulls data from Spotify, processes it, and writes it to the database. |
| **Navigation** | After data ingestion the user is redirected to `/tools/<username>`. |

---

## 2. Dependencies

| Dependency | Why it is needed | What is imported / used |
|------------|------------------|--------------------------|
| `dash` | Provides the web framework and page registration. | `dash`, `dash.register_page` |
| `dash.dcc` | Dash Core Components (e.g., `Location`, `Input`). | `dcc` |
| `dash.html` | Dash HTML Components for building the UI. | `html` |
| `dash.dependencies` | Input/Output/State objects for callbacks. | `Input`, `Output`, `State` |
| `spotify` | Wrapper around the Spotipy library to fetch Spotify data. | `spotify_init`, `get_liked_songs`, `process_liked_songs`, `recent_songs`, `get_artists`, `get_albums`, `process_artists`, `process_albums` |
| `postgres` | Database helper functions for creating tables and inserting data. | `create_liked_songs_table`, `check_liked_songs`, `add_liked_songs_dict`, `create_recent_songs_table`, `create_artist_table`, `select_unique_artists`, `add_artists_dict`, `create_album_table`, `select_unique_albums`, `add_albums_dict` |
| `pandas` | Convert lists of dictionaries into DataFrames for filtering. | `pd.DataFrame` |
| `datetime` | Parse ISO‑8601 timestamps returned by Spotify. | `datetime.fromisoformat` |

> **Note:** All dependencies are explicitly listed in the `external_dependencies` field of the JSON evidence.

---

## 3. Functions

### 3.1 `layout()`

```python
def layout():
    return html.Div([
        dcc.Location(id='url', refresh=True),
        html.Div([
            html.Div([...], className='left'),
            html.Div([...], className='right')
        ], className='box-form')
    ])
```

*Builds the login page UI.*

- **`dcc.Location`** – used to programmatically change the URL after login.
- **Left pane** – title and description.
- **Right pane** – username input (`dcc.Input`) and a “Login” button.

### 3.2 `check_date(timestamp: str) -> datetime`

```python
def check_date(timestamp):
    return datetime.fromisoformat(timestamp[:-1])
```

*Converts Spotify’s ISO‑8601 timestamp (which ends with a trailing `Z`) into a Python `datetime` object.*

### 3.3 `fetch_data(username: str)`

```python
def fetch_data(username):
    token = spotify.spotify_init(username)

    # 1. Liked songs
    songs = spotify.get_liked_songs(token)
    songs_dict = spotify.process_liked_songs(songs)
    df = pd.DataFrame.from_dict(songs_dict)
    postgres.create_liked_songs_table()
    res, flag = postgres.check_liked_songs('liked_songs')
    if flag:
        df['added_at'] = df['added_at'].apply(check_date)
        df = df[df['added_at'] > res]
    songs_dict = list(df.T.to_dict().values())
    postgres.add_liked_songs_dict(songs_dict, 'liked_songs')

    # 2. Recent songs
    recent_songs = spotify.recent_songs(token)
    recent_songs_dict = spotify.process_liked_songs(recent_songs)
    recent_df = pd.DataFrame.from_dict(recent_songs_dict)
    postgres.create_recent_songs_table()
    res, flag = postgres.check_liked_songs('recents')
    if flag:
        recent_df['added_at'] = recent_df['added_at'].apply(check_date)
        recent_df = recent_df[recent_df['added_at'] > res]
    recent_songs_dict = list(recent_df.T.to_dict().values())
    postgres.add_liked_songs_dict(recent_songs_dict, 'recents')

    # 3. Master list of unique songs
    master_songs_dict = list(set(songs_dict + recent_songs_dict))

    # 4. Artists
    artist_ids_spotify = list(set(i['artists'] for i in master_songs_dict))
    artists = spotify.get_artists(token, artist_ids_spotify)
    postgres.create_artist_table()
    artist_ids_tuple = postgres.select_unique_artists()
    artist_ids = [i[0] for i in artist_ids_tuple]
    new_artists = [a for a in artists if a['id'] not in artist_ids]
    artists = spotify.process_artists(new_artists)
    postgres.add_artists_dict(artists)

    # 5. Albums
    album_ids_spotify = list(set(i['album'] for i in master_songs_dict))
    albums = spotify.get_albums(token, album_ids_spotify)
    postgres.create_album_table()
    album_ids_tuple = postgres.select_unique_albums()
    album_ids = [i[0] for i in album_ids_tuple]
    new_albums = [a for a in albums if a['id'] not in album_ids]
    albums = spotify.process_albums(new_albums)
    postgres.add_albums_dict(albums)
```

*What it does:*

1. **Authenticate** the user via `spotify_init`.
2. **Fetch liked songs**, process them into a flat dictionary, and store only new entries in the `liked_songs` table.
3. **Fetch recent songs**, process them similarly, and store new entries in the `recents` table.
4. **Build a master list** of all unique songs (liked + recent).
5. **Retrieve artist data** for all unique artists, filter out already‑stored artists, process, and insert new ones.
6. **Retrieve album data** for all unique albums, filter out already‑stored albums, process, and insert new ones.

> **Why these steps?**  
> The app needs a local, query‑friendly copy of the user’s music data.  
> By filtering on `added_at` only new records are inserted, keeping the database size manageable.

### 3.4 Callback – `button_on_clicked`

```python
@callback(
    Output('url', 'pathname'),
    [Input('username_submit_button', 'n_clicks')],
    [State('username_input', 'value')]
)
def button_on_clicked(n_clicks, value):
    if value is None:
        return '/'
    else:
        fetch_data(value)
        return f'/tools/{value}'
```

*Triggered when the “Login” button is pressed.*

- If no username is entered, the user stays on the login page.
- Otherwise, `fetch_data` is called to ingest data, then the browser is redirected to `/tools/<username>`.

> **Note:** The callback returns a string that updates the `pathname` of the hidden `dcc.Location` component, causing a client‑side navigation.

### 3.5 Commented‑out callback

```python
'''
@callback(
    Output('placeholder','children'),
    [Input('interval-component','n_intervals')],
    [State('username_input', 'value')]
)
def time_based_calc(n_intevrals,username):
    fetch_data(username)
'''
```

*This code is currently inactive. If enabled, it would periodically refresh the data while the user is on the page.*

---

## 4. How the Module Fits Into the System

| Module | Interaction |
|--------|-------------|
| `pages.tools` | After login, the user is redirected to `/tools/<username>`. |
| `pages.liked_songs`, `pages.recents`, `pages.analytics` | These pages query the tables created by `fetch_data` to display data. |
| `postgres` | Provides all CRUD operations used by `fetch_data`. |
| `spotify` | Supplies all data‑fetching and processing functions. |

> **Dependency chain**  
> `cred` → `spotify` (data retrieval) → `postgres` (storage) → other pages (data display).

---

## 5. Usage Summary

1. **User visits `/`** – sees the login form.
2. **User enters Spotify username** and clicks **Login**.
3. `button_on_clicked` callback:
   - Calls `fetch_data(username)` to pull and store data.
   - Redirects to `/tools/<username>`.
4. Subsequent navigation to `/liked/<username>`, `/recents/<username>`, or `/analytics/<username>` pulls data from the PostgreSQL tables created by `fetch_data`.

---

## 6. Things to Note

- **No docstrings** are present in the source; documentation is derived solely from the code and JSON evidence.
- **Error handling** is minimal – if Spotify authentication fails or the database is unreachable, the app will raise an exception.
- **Data freshness**: The `check_liked_songs` function only compares the maximum `added_at` timestamp; it assumes that newer songs are appended chronologically.
- **Performance**: Large playlists may cause long fetch times; consider pagination or background jobs for production use.

---

## 7. Quick Reference

```python
# Import the module
import pages.cred as cred

# Render the login page
app.layout = cred.layout()

# Trigger data ingestion manually (e.g., from a script)
cred.fetch_data('my_spotify_username')
```

This completes the documentation for `pages.cred`.