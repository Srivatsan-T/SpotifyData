# `spotify.py` – Spotify Data Retrieval & Processing

**Location:** `/app/cloned_repos/spotify_data/spotify.py`

This module is the single point of interaction with the Spotify Web API.  
It authenticates a user, pulls raw data (liked songs, recent plays, albums, artists) and
provides helper functions that transform that raw data into a format suitable for
storage in the PostgreSQL database used by the rest of the application.

> **Note** – The module has no docstrings or type hints; all behaviour is inferred
> from the source code and the relationships listed in the evidence.

---

## 1. Imports & Global Configuration

| Import | Purpose |
|--------|---------|
| `spotipy` | Official Spotify Web API wrapper. |
| `pandas as pd` | Used only in the `pages.cred` module for DataFrame conversion. |
| `os` | Access environment variables. |
| `dotenv.load_dotenv` | Load `.env` file into `os.environ`. |

```python
import spotipy
import pandas as pd
import os
from dotenv import load_dotenv

load_dotenv()
```

### Global Variables

| Variable | Value | Usage |
|----------|-------|-------|
| `username` | `"Srivatsan Thiruvengadam"` | Defined but never used in this module. |
| `client_id` | `os.getenv("CLIENT_ID")` | Spotify client ID from environment. |
| `client_secret` | `os.getenv("CLIENT_SECRET")` | Spotify client secret from environment. |
| `redirect_uri` | `'http://localhost:7777/callback'` | Redirect URI registered in Spotify dashboard. |
| `scope` | `'user-read-recently-played user-library-read'` | Permissions requested during OAuth. |

These globals are used by `spotify_init` to request an OAuth token.

---

## 2. Core Functions

### 2.1 `spotify_init(spotify_username)`

```python
def spotify_init(spotify_username):
    token = spotipy.util.prompt_for_user_token(
        username=spotify_username,
        scope=scope,
        client_id=client_id,
        client_secret=client_secret,
        redirect_uri=redirect_uri
    )
    return token
```

* **Purpose** – Initiates the OAuth flow for a given Spotify username and returns an access token.
* **Dependencies** – `spotipy.util.prompt_for_user_token`, `scope`, `client_id`, `client_secret`, `redirect_uri`.
* **Usage** – Called by `pages.cred.fetch_data` to obtain a token that is then passed to all other functions.

---

### 2.2 `recent_songs(token)`

```python
def recent_songs(token):
    sp = spotipy.Spotify(token)
    user_recent = sp.current_user_recently_played(limit=50)
    for i in user_recent['items']:
        i['added_at'] = i['played_at']
    return user_recent['items']
```

* **Purpose** – Retrieves the 50 most recent tracks the user has played.
* **Return** – List of item dictionaries (each contains `track`, `played_at`, etc.).
* **Side‑effect** – Adds an `added_at` key to each item, mirroring `played_at`.
* **Usage** – In `pages.cred.fetch_data`, the result is passed to `process_liked_songs`.

---

### 2.3 `get_liked_songs(token)`

```python
def get_liked_songs(token):
    sp = spotipy.Spotify(token)
    lim = 50
    off = 0
    songs = []
    next = 'not none'
    while next is not None:
        liked_songs = sp.current_user_saved_tracks(offset=off, limit=lim)
        for i in liked_songs['items']:
            songs.append(i)
        off += lim
        next = liked_songs['next']
    return songs
```

* **Purpose** – Fetches all tracks the user has saved to their library.
* **Pagination** – Uses `offset`/`limit` until `next` is `None`.
* **Return** – List of full track objects (including album, artists, etc.).
* **Usage** – In `pages.cred.fetch_data`, the result is processed by `process_liked_songs`.

---

### 2.4 `get_albums(token, album_ids)`

```python
def get_albums(token, album_ids):
    sp = spotipy.Spotify(token)
    albums = []
    number_of_ids = len(album_ids)
    if album_ids:
        for i in range(int(number_of_ids/20)):
            albums.extend(sp.albums(album_ids[20*i:20*i+20])['albums'])
        albums.extend(sp.albums(album_ids[int(number_of_ids/20)*20:])['albums'])
    return albums
```

* **Purpose** – Batch‑fetch album details for a list of album IDs.
* **Batch Size** – 20 IDs per request (Spotify API limit).
* **Return** – List of album objects.
* **Usage** – In `pages.cred.fetch_data`, after deduplicating album IDs, the result is processed by `process_albums`.

---

### 2.5 `get_artists(token, artist_ids)`

```python
def get_artists(token, artist_ids):
    sp = spotipy.Spotify(token)
    artists = []
    number_of_ids = len(artist_ids)
    if artist_ids:
        for i in range(int(number_of_ids/50)):
            artists.extend(sp.artists(artist_ids[50*i:50*i+50])['artists'])
        artists.extend(sp.artists(artist_ids[int(number_of_ids/50)*50:])['artists'])
    return artists
```

* **Purpose** – Batch‑fetch artist details for a list of artist IDs.
* **Batch Size** – 50 IDs per request (Spotify API limit).
* **Return** – List of artist objects.
* **Usage** – In `pages.cred.fetch_data`, after deduplicating artist IDs, the result is processed by `process_artists`.

---

### 2.6 `process_liked_songs(liked_songs)`

```python
def process_liked_songs(liked_songs):
    number_of_songs = len(liked_songs)
    songs_dict = []
    for i in range(number_of_songs):
        temp_dict = {}
        temp_dict['song_id'] = liked_songs[i]['track']['id']
        temp_dict['song_name'] = liked_songs[i]['track']['name']
        temp_dict['added_at'] = liked_songs[i]['added_at']
        temp_dict['album'] = liked_songs[i]['track']['album']['id']
        temp_dict['popularity'] = liked_songs[i]['track']['popularity']
        temp_dict['preview_url'] = liked_songs[i]['track']['preview_url']
        temp_dict['duration_ms'] = liked_songs[i]['track']['duration_ms']

        for artist in liked_songs[i]['track']['artists']:
            temp_dict['artists'] = artist['id']
            songs_dict.append(temp_dict.copy())
    return songs_dict
```

* **Purpose** – Normalises liked‑song data into a flat list of dictionaries.
* **Key Fields** – `song_id`, `song_name`, `added_at`, `album`, `popularity`, `preview_url`, `duration_ms`, `artists`.
* **Artist Handling** – For each artist in a track, a separate dictionary is appended (duplicate track entries for multiple artists).
* **Return** – List of dictionaries ready for insertion into the `liked_songs` table.

---

### 2.7 `process_albums(albums)`

```python
def process_albums(albums):
    number_of_songs = len(albums)
    album_dict = []
    for i in range(number_of_songs):
        temp_dict = {}
        temp_dict['album_id'] = albums[i]['id']
        temp_dict['album_name'] = albums[i]['name']
        temp_dict['popularity'] = albums[i]['popularity']

        for genre in albums[i]['genres']:
            temp_dict['genres'] = genre
            album_dict.append(temp_dict.copy())
        if not albums[i]['genres']:
            temp_dict['genres'] = 'N.A'
        for artist in albums[i]['artists']:
            temp_dict['artists'] = artist['id']
            album_dict.append(temp_dict.copy())
    return album_dict
```

* **Purpose** – Normalises album data into a flat list of dictionaries.
* **Key Fields** – `album_id`, `album_name`, `popularity`, `genres`, `artists`.
* **Genre & Artist Handling** – Creates separate entries for each genre and each artist.
* **Return** – List of dictionaries ready for insertion into the `album` table.

---

### 2.8 `process_artists(artists)`

```python
def process_artists(artists):
    number_of_songs = len(artists)
    artist_dict = []
    for i in range(number_of_songs):
        temp_dict = {}
        temp_dict['artist_id'] = artists[i]['id']
        temp_dict['artist_name'] = artists[i]['name']
        temp_dict['popularity'] = artists[i]['popularity']
        temp_dict['followers'] = artists[i]['popularity']   # likely a bug – should be followers count

        for genre in artists[i]['genres']:
            temp_dict['genres'] = genre
            artist_dict.append(temp_dict.copy())
        if not artists[i]['genres']:
            temp_dict['genres'] = 'N.A'
    return artist_dict
```

* **Purpose** – Normalises artist data into a flat list of dictionaries.
* **Key Fields** – `artist_id`, `artist_name`, `popularity`, `followers`, `genres`.
* **Genre Handling** – Creates separate entries for each genre.
* **Return** – List of dictionaries ready for insertion into the `artist` table.

---

## 3. Interaction with the Rest of the Codebase

| Module | Function | How It Is Used |
|--------|----------|----------------|
| `pages.cred` | `spotify_init`, `get_liked_songs`, `recent_songs`, `get_artists`, `get_albums`, `process_liked_songs`, `process_albums`, `process_artists` | `fetch_data(username)` obtains a token, pulls data, processes it, and stores it in PostgreSQL. |
| `pages.cred.fetch_data` | Same as above | Directly calls the functions to populate the database. |

The module has no other dependencies or consumers. All data flow originates from the user’s Spotify account, is transformed by the helper functions, and then persisted via the `postgres` module.

---

## 4. External Dependencies

| Dependency | Purpose |
|------------|---------|
| `dotenv.load_dotenv` | Loads `.env` file for `CLIENT_ID` and `CLIENT_SECRET`. |
| `os` | Reads environment variables. |
| `pandas` | Imported but only used in `pages.cred` for DataFrame conversion. |
| `spotipy` | Handles OAuth and API requests. |

---

## 5. Summary of Data Flow

1. **User logs in** → `pages.cred.fetch_data` calls `spotify.spotify_init(username)` → OAuth token returned.
2. **Data retrieval** → `get_liked_songs`, `recent_songs`, `get_artists`, `get_albums` fetch raw data.
3. **Data normalization** → `process_liked_songs`, `process_albums`, `process_artists` convert raw JSON into flat dictionaries.
4. **Database persistence** → `postgres.add_*_dict` functions insert the processed data into the appropriate tables.

---

## 6. Things to Note

* The `username` global variable is defined but never used; the username is passed explicitly to `spotify_init`.
* `process_artists` mistakenly sets `followers` to the popularity value; this may be a bug.
* The module does not expose any classes or constants beyond the functions listed.
* No type hints or docstrings are present; developers should refer to the function signatures and the usage in `pages.cred` for guidance.

---

**End of Documentation**